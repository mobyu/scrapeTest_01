### 免费代理池维护

1. 代理池分为四个基本模块  

   + 储存模块：储存爬取下来的代理  
   + 获取模块：定时在各大代理网站爬取代理
   + 检测模块：定时检测储存模块中的代理是否可用
   + 接口模块：勇API提供对外服务的接口

2. 存储模块  
   使用Redis的有序集合，集合中每个元素即使代理，例如：60.207.237.111:8888  
   有序集合中每个元素都有一个分数字段，根据元素分数大小进行排序，实现有序。
   分数设置方案：
   ```tex
   新获取的代理的设置分数为10；一经验证可用设置为100；如果检测到代理不可用，将分数减1，减到0，删除该代理
   原因：
   	1.免费代理网站获取代理不稳定，存在一定失败率，如果可用设为100，确保代理有机会被调用；
   	2.连续失败100次才将代理删除，是因为可用代理十分宝贵；
   	3.新获取的代理连续失败10次即删除，减小开销。
   ```  
   语法解释：
   ```python
   def random(self) -> Proxy:
       pass
   # -> 主要是标记返回值数据类型,这样只看代码就知道该方法返回什么类型数据。
    ```  
   + \_\_init__方法用于初始化，参数是Redis的链接信息，默认链接信息定义为常量；
   + add方法添加代理并设置分数；
   + random方法用户随机获取代理，首先获取分数为100的代理，然后从中随机返回一个；如果不存在100分，按照排名，获取前100位代理，然后随机返回一个；否则抛出异常；
   + decrease检测到无效代理，减1分；
   + exists判断代理是否存在于合集中；
   + max 将代理的分数设为PROXY_SCORE_MAX（100）
   + count 返回集合中元素个数（未失效代理个数）
   + all 返回集合中所有元素的列表。
   
3. 获取模块  
   在父类中实现通用爬取的fetch方法，然后在每个子类里实现解析方法  
4. 检测模块  
   使用aiohttp库进行异步检测  
5. 接口模块  
   考虑因素：
   + redis信息安全；  
   + 远程redis服务器如果只允许本地连接；
   + 爬虫所在主机没有连接redis模块；或这爬虫不是由python编写；
   + RedisClient或者数据结构更新，爬虫端必须同步  
   综上：将代理池作为独立服务运行，增加接口模块，使用Flask库来实现。  
6. 调度模块  
   对测试模块，获取模块和接口模块都设置开关
   然后使用多线程
   
###付费代理
1.付费代理分类  
  按照使用流程大致分为两类代理：  
  + 代理商提供代理提取接口的付费代理；
  + 代理商搭建了隧道代理的付费代理，可以直接将此类代理设置为固定的IP和端口，无需进一步通过请求接口获取随即代理并设置。（代理商进行了代理池的维护）  
    + 私密代理
    + 隧道代理
    
##ADSL拨号代理的搭建方法
ADSL（Asymmetric Digital Subscriber Line）非对称数字用户环路。  
它的上行带宽和下行带宽不对称，采用频分复用技术把普通电话分成了电话，上行和下行三个相对独立的信道，从而避免相互干扰。  
IP分布在多个A段，量级为千万级，如果将ADSL主机作为代理，隔时拨号更换IP可以防止IP封禁，此外稳定性也会更好。  
购买ADSL云服务器，安装代理软件（流行的有Squid和TinyProxy）。  
动态获取IP cui在Pypi上发布了一个adslproxy的工具。

# 模拟登录  

## 模拟登录原理

1. 模拟登录主要分为两种模式：
   - 基于Session和Cookie；  
   - 基于JWT（JSON Web Token）的模拟登录  
     前后端分离式，请求数据时服务器会校验请求中携带的JWT是否有效   

2. 基于Session和Cookie  
Cookie和Session一定是相互配合工作。
   + Cookie里可能只保存了SessionID相关信息，服务器就能根据这个信息找到对应的Session；  
   + Cookie直接保存了某些凭证信息。  
3. 基于JWT  
   Session和Cookie的校验存在一定问题：  
   + 服务器需维护用户登录的Session信息；
   + 分布式部署不方便，不适合前后端分离的项目。  
   
   JWT是为了在网络环境中传递而执行的一种基于JSON的开放标准，实际上就是在每次登录时都通过一个Token字段校验登录状态，  
   一般用来在身份提供者和服务提供者之间传递要认证的用户身份信息。，以便从资源服务器获取资源，此外可以增加一些业务必要的校验逻辑。
   JWT一般是一个经过Base64加密的字符串，拥有自己的标准，如下：
   ```text
   eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImJhb2JhbyIsImV4cCI6MTU5OTkyMjUyOCwidXNlcklkIjoyMX0.YhA3kh9KZOAb7om1C7o3vBhYp0f61mhQWWOoCrrhqvo
    ```       
   中间有两个分隔作用的'.'，三段式加密，分别为Header，Payload和Signature：  
   + Header：声明JWT的签名算法（加密算法），还可能包括JWT编号或者类型；  
   + Payload：通常为业务需要但不敏感信息；  
   + Signature：签名，利用密钥secret对Header和Payload的信息加密后形成的，这个密钥保存在服务器端。如果Header和Payload被修改，可以通过Signature来判断。  
   
4. 模拟登录  
5. 账号池  
   通过账号分流防止被封  

## 账号池
1. 账号池具备的功能：  
    + 能够保存登录目标站点的账号和登陆后的Cookie信息；
    + 定时检测每个Cookie的有效性，如果失效，重新模拟登录生成；
    + 一个数据获取接口，能够获取随机Cookie的接口。  
2. 账号池架构
   + 存储模块：负责储存每个账号的用户名，密码以及账号对应的Cookie信息；  
   + 获取模块：负责生成新的Cookie并储存；  
   + 检测模块：需要定时检测存储模块中Cookie的有效性；  
   + 接口模块：使用API提供对外服务的接口，随机存取。  
3. 存储模块  
   存储的内容为***账号信息***和***Cookie***信息  
   账号：用户名+密码  
   
   
# JavaScript逆向爬虫
## 网站加密和混淆技术  
根据保护对象分为：  
1. URL/API参数加密；  
    通过约定客户端和服务端的接口校验方式，通常会使用到加密技术。  
    例如：双方约定一个sign作为接口校验的签名，客户端将URL路径进行MD5加密，然后拼接上某个参数再进行Base64编码，得到sign，客户端会对内容做同样的出来，判断sign是否一致，从而判断内容是否被篡改。  
2. JavaScript压缩、混淆和加密：  
    不能单纯依靠接口加密技术解决问题，愿意：  
    + JavaScript代码运行与客户端，它必须在用户浏览器端加载并运行；
    + JavaScript代码是公开透明的，也就是说浏览器可以直接获取到正在运行的JavaScript的源码。  
    
    JavaScript代码压缩、混淆和加密技术：
    + 代码压缩：去除代码中不必要的的空格、换行等内容，使源码压缩为几行内容，降低代码的可读性同时提高网站的加载速度；  
        主流前端技术会用webpack和Rollup等工具进行打包，它们会对远大吗进行编译和压缩；  
    + 代码混淆：使用变量替换、字符串阵列化、控制流平坦化、多态变异、僵尸函数、调试保护等手段，将代码变得难以阅读和分析；  
        现在JavaScript混淆的主流实现是***javascript-obfuscator***、***terser***两个库
    + 代码加密：通过某种手段将JavaScript代码进行加密，转成人无法阅读或者解析的代码，例如WebAssembly技术，它可以将JavaScript代码用C/C++实现，JavaScript调用其编译形成后的文件来执行相应功能。  
    + 变量名混淆：可以在javascript-obfuscator中identifierNamesGenerator来实现，如：将其值设为hexadecimal，则会将变量名替换为十六进制。  
    + 字符串混淆：将一个字符串放到一个数组里面，使之无法被直接搜索到。可以通过stringArray参数控制，默认为true；  
    + 代码自我保护：我们可以通过设置selfDefending参数开启代码自我保护功能。开启之后，混淆后的JavaScript会强制以一行形式显示，如果将混淆后的代码进行格式化或者重命名，改代码将无法执行。  
    + 控制流平坦化：其实是将代码的执行逻辑混淆，使其变得复杂、难度。其基本思想是将一些逻辑处理块都统一加上一个前驱逻辑块，每个逻辑块都由前置逻辑块进行条件判断和分发，构成闭环逻辑，导致整个执行逻辑复杂、难读。  
    + 无用代码注入：无用代码即不会被执行的代码或对上下文没有任何影响的代码，诸如后可以对现有的JavaScript代码阅读形成干扰。可以使用deadCodeInjection参数开启这个选项，默认为false。  
    + 对象键名替换：如果是一个对象，可以使用transformObjectKeys来对对象的键值进行替换。  
    + 禁用控制台输出：可以使用disableConsoleOutput来禁用掉console.log输出功能，增大调试难度；  
    + 调试保护：在Javascript代码中加入debugger关键字，执行到该位置时，就会进入断点调试模式。如果在多个位置加入debugger，或者某个逻辑反复执行debugger就会反复进入断点调试模式，原本的代码就无法顺畅执行。  
    + 域名锁定：通过控制domainLock来控制JavaScript代码只能在特定域名下运行，降低被模仿或者盗用的风险；
    + 特殊编码：使用特殊的工具包（aaencode、jjencode、jsfuck等）对代码进行混淆和编码；  
3.WebAssembly  
    基本思路：将核心逻辑代码使用其他语言（C/C++）来编写，并编译成类似字节码的文件并通过JavaScript来调用，从而起到二进制级别的防护。  

## 浏览器常用技巧  
1. Elements：元素面板，用于查看或者修改当前网页HTML节点的属性、CSS属性、监听时间。HTML和CSS头可以即时修改和即时显示。
    + 改写JavaScript文件，将浏览器原始JavaScript保存后修改再使用Chrome原始Overrides替换。  
2. JavaScript Hook的使用
    + Hook技术：又叫钩子技术，指再程序运行的过程中，对其中的某个方法进行重写，在原先的方法前后加入自定义代码。相当于在系统没有调用该函数之前，钩子程序先捕获该消息，得到控制权，此时钩子函数既可以加工处理该函数的执行行为，也可以强制结束消息的传递。  
    + 油猴脚本  
3. 模拟登录：
    + 使用断点寻找token生成的规则；  
    + 使用hook函数，改写目标函数使目标信息展示出来。例如在调用目标函数前展示信息；  
    + 无限debugger，如每秒钟进行一次debugger，类似的还有无限for循环，while循环，无限递归等；  
        + 禁用断点：使用全局禁用，或者局部禁用甚至添加禁用条件来控制断点；  
        + 替换文件：在新文件里将debugger关键字删除。  

## 使用Node.js执行JavaScript  
1. 安装node.js  
2. 拿到JavaScript加密方法的代码；  
3. 使用node.js调用加密方法获取Token；  
4. 可以使用npm安装express框架将node.js作为持续监听服务，post请求获取数据。
## 局部调用游览器  
1. 直接使用浏览器进行局部方法调用； 
2. 将局部方法挂载到全局window对象上；  
3. 利用playwright的Request Interception机制将想要替换的任意文件进行替换，然后修改源码。

## ATS  
ATS全称Abstract Syntax Tree,抽象语法树。  
一段代码执行前通常进行的三个步骤：
1. 词法分析：一段代码先会被分解成一段段有意义的词法单元；  
2. 语法分析:接着编译器会对一个个词法单元进行语法分析，将其转换为能代表程序语法结构的数据结构；  
3. 指令生成：最后将ATS转换为实际真正可执行的指令并执行。


#### 20220208  
##### Charles抓包
1. 安装java及ideal 2021.3；
2. 安装charles并进行手机抓包
    + 电脑端安装证书；
    + 手机端安装证书并信任（手机访问chls.pro/ssl下载证书）；
    + 手机端设置代理。  
3. 功能：  
    + 分析请求；
    + 重发请求：将捕获到的请求内容加以修改并把修改后的内容发送出去；
    + 修改响应内容： 例如可以将响应内容修改为本地或者远程的某个文件，实现数据的修改和伪造；
##### mitmproxy  
1. 手机端设置代理后需要访问mitm.it来下载证书

####  mitmdump
1. 配合py脚本可以抓取App相关请求内容。例如:mitmdump -s script.py  
    ```python
   def response(flow):
       # flow.request.headers['User-Agent'] = 'MitmProxy'
       print(flow.request.url)
       print(flow.response.text)
   ```
  可以打印请求url和响应内容。
####  appium   
1. 安装Android Studio及配置Android SDK；
2. 安装appium-inspector,但是没有搞清楚怎么使用。
####  Airtest
1. 安装Airtest并尝试使用；
2. 运行过程出错cannot import name ‘_registerMatType‘。  
    原因：同时安装了opencv-python和opencv-contrib-python 版本之间不匹配造成的  
    解决方法：卸载一项后再次安装相同版本的包即可。
3. 基于Poco的UI组件自动化