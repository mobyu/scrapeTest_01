### 免费代理池维护

1. 代理池分为四个基本模块  

   + 储存模块：储存爬取下来的代理  
   + 获取模块：定时在各大代理网站爬取代理
   + 检测模块：定时检测储存模块中的代理是否可用
   + 接口模块：勇API提供对外服务的接口

2. 存储模块  
   使用Redis的有序集合，集合中每个元素即使代理，例如：60.207.237.111:8888  
   有序集合中每个元素都有一个分数字段，根据元素分数大小进行排序，实现有序。
   分数设置方案：
   ```tex
   新获取的代理的设置分数为10；一经验证可用设置为100；如果检测到代理不可用，将分数减1，减到0，删除该代理
   原因：
   	1.免费代理网站获取代理不稳定，存在一定失败率，如果可用设为100，确保代理有机会被调用；
   	2.连续失败100次才将代理删除，是因为可用代理十分宝贵；
   	3.新获取的代理连续失败10次即删除，减小开销。
   ```  
   语法解释：
   ```python
   def random(self) -> Proxy:
       pass
   # -> 主要是标记返回值数据类型,这样只看代码就知道该方法返回什么类型数据。
    ```  
   + \_\_init__方法用于初始化，参数是Redis的链接信息，默认链接信息定义为常量；
   + add方法添加代理并设置分数；
   + random方法用户随机获取代理，首先获取分数为100的代理，然后从中随机返回一个；如果不存在100分，按照排名，获取前100位代理，然后随机返回一个；否则抛出异常；
   + decrease检测到无效代理，减1分；
   + exists判断代理是否存在于合集中；
   + max 将代理的分数设为PROXY_SCORE_MAX（100）
   + count 返回集合中元素个数（未失效代理个数）
   + all 返回集合中所有元素的列表。
   
3. 获取模块  
   在父类中实现通用爬取的fetch方法，然后在每个子类里实现解析方法  
4. 检测模块  
   使用aiohttp库进行异步检测  
5. 接口模块  
   考虑因素：
   + redis信息安全；  
   + 远程redis服务器如果只允许本地连接；
   + 爬虫所在主机没有连接redis模块；或这爬虫不是由python编写；
   + RedisClient或者数据结构更新，爬虫端必须同步  
   综上：将代理池作为独立服务运行，增加接口模块，使用Flask库来实现。  
6. 调度模块  
   对测试模块，获取模块和接口模块都设置开关
   然后使用多线程
   
###付费代理
1.付费代理分类  
  按照使用流程大致分为两类代理：  
  + 代理商提供代理提取接口的付费代理；
  + 代理商搭建了隧道代理的付费代理，可以直接将此类代理设置为固定的IP和端口，无需进一步通过请求接口获取随即代理并设置。（代理商进行了代理池的维护）  
    + 私密代理
    + 隧道代理
    
##ADSL拨号代理的搭建方法
ADSL（Asymmetric Digital Subscriber Line）非对称数字用户环路。  
它的上行带宽和下行带宽不对称，采用频分复用技术把普通电话分成了电话，上行和下行三个相对独立的信道，从而避免相互干扰。  
IP分布在多个A段，量级为千万级，如果将ADSL主机作为代理，隔时拨号更换IP可以防止IP封禁，此外稳定性也会更好。  
购买ADSL云服务器，安装代理软件（流行的有Squid和TinyProxy）。  
动态获取IP cui在Pypi上发布了一个adslproxy的工具。

# 模拟登录  

## 模拟登录原理

1. 模拟登录主要分为两种模式：
   - 基于Session和Cookie；  
   - 基于JWT（JSON Web Token）的模拟登录  
     前后端分离式，请求数据时服务器会校验请求中携带的JWT是否有效   

2. 基于Session和Cookie  
Cookie和Session一定是相互配合工作。
   + Cookie里可能只保存了SessionID相关信息，服务器就能根据这个信息找到对应的Session；  
   + Cookie直接保存了某些凭证信息。  
3. 基于JWT  
   Session和Cookie的校验存在一定问题：  
   + 服务器需维护用户登录的Session信息；
   + 分布式部署不方便，不适合前后端分离的项目。  
   
   JWT是为了在网络环境中传递而执行的一种基于JSON的开放标准，实际上就是在每次登录时都通过一个Token字段校验登录状态，  
   一般用来在身份提供者和服务提供者之间传递要认证的用户身份信息。，以便从资源服务器获取资源，此外可以增加一些业务必要的校验逻辑。
   JWT一般是一个经过Base64加密的字符串，拥有自己的标准，如下：
   ```text
   eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImJhb2JhbyIsImV4cCI6MTU5OTkyMjUyOCwidXNlcklkIjoyMX0.YhA3kh9KZOAb7om1C7o3vBhYp0f61mhQWWOoCrrhqvo
    ```       
   中间有两个分隔作用的'.'，三段式加密，分别为Header，Payload和Signature：  
   + Header：声明JWT的签名算法（加密算法），还可能包括JWT编号或者类型；  
   + Payload：通常为业务需要但不敏感信息；  
   + Signature：签名，利用密钥secret对Header和Payload的信息加密后形成的，这个密钥保存在服务器端。如果Header和Payload被修改，可以通过Signature来判断。  
   
4. 模拟登录  
5. 账号池  
   通过账号分流防止被封  
